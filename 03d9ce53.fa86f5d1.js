(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{163:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return o})),a.d(t,"metadata",(function(){return i})),a.d(t,"rightToc",(function(){return c})),a.d(t,"default",(function(){return l}));var n=a(1),r=a(9),s=(a(0),a(196)),o={lip:4,title:"Transaction Metadata Specification",authors:"Kevin Hurley (@kphfb)",status:"draft",type:"informational",created:"06/26/2020"},i={id:"lip-4",title:"Transaction Metadata Specification",description:"# Summary",source:"@site/all-docs__GENERATED/lip-4.md",permalink:"/lip-4",editUrl:"https://github.com/libra/lip/edit/master/all-docs__GENERATED/lip-4.md"},c=[{value:"Submitting a transaction",id:"submitting-a-transaction",children:[]},{value:"Processing the transaction",id:"processing-the-transaction",children:[]},{value:"NC to NC transaction Flow",id:"nc-to-nc-transaction-flow",children:[]},{value:"NC to C Transaction Flow",id:"nc-to-c-transaction-flow",children:[]},{value:"C to NC transaction flow",id:"c-to-nc-transaction-flow",children:[]},{value:"Refunds",id:"refunds",children:[]},{value:"C to C transaction flow",id:"c-to-c-transaction-flow",children:[]}],d={rightToc:c};function l(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(s.b)("wrapper",Object(n.a)({},d,a,{components:t,mdxType:"MDXLayout"}),Object(s.b)("h1",{id:"summary"},"Summary"),Object(s.b)("hr",null),Object(s.b)("p",null,"Merchants and wallet holders may rely on third parties to maintain custody of their wallet and may optionally want to receive additional data in transactions.  Libra leverages subaddressing to provide this functionality."),Object(s.b)("hr",null),Object(s.b)("h1",{id:"terminology"},"Terminology"),Object(s.b)("hr",null),Object(s.b)("p",null,Object(s.b)("em",{parentName:"p"},"subaddress:")," Accounts on-chain are represented by an address.  To allow multiplexing of a single address into multiple wallets, custodial wallets may utilize \u201csubaddresses\u201d under the on-chain address for each underlying user.  These subaddresses represent the users and may have meaning only to the custodian - but the mapping from subaddress to user is not known on-chain, but rather is an internal mapping known by the custodian.  The best practice is to use subaddresses as a single-use address to remove linkability.  In this way, subaddresses serve as a many-to-one mapping between subaddresses and a user - where ideally subaddresses are not re-used for more than one payment."),Object(s.b)("p",null,Object(s.b)("em",{parentName:"p"},"referenced_event:")," In the case where funds must be returned, referenced_event refers to the event sequence number of the original sender\u2019s sent payment event.  Since refunds are just another form of p2p transfer, the referenced event field allows a refunded payment to refer back to the original payment."),Object(s.b)("hr",null),Object(s.b)("h1",{id:"abstract--motivation"},"Abstract / Motivation"),Object(s.b)("hr",null),Object(s.b)("p",null,"Merchants and wallet holders may rely on third parties to maintain custody of their wallet and may optionally want to receive additional data in transactions.  Libra leverages subaddressing to provide this functionality.  This document describes an approach to supporting transactions like this by defining a standard that supports:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Subaddressing to support multiplexing a single account address into multiple wallets, enabling custodial wallets to maintain a single address rather than maintain numerous addresses.")),Object(s.b)("p",null,"As an example, assume a recipient account provides custodial wallets. To send funds to this wallet within Libra:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"The recipient crafts a QR code containing a URI that references the account hosting the custodial wallet and a reference to their wallet."),Object(s.b)("li",{parentName:"ul"},"The consumer scans the QR code and constructs a transaction and includes within it the subaddress."),Object(s.b)("li",{parentName:"ul"},"Once the transaction has been submitted and committed to the blockchain, the custodial wallet notifies the recipient of the transaction and credits the account associated with the subaddress.")),Object(s.b)("hr",null),Object(s.b)("h1",{id:"specification"},"Specification"),Object(s.b)("hr",null),Object(s.b)("h1",{id:"the-lifetime-of-a-transaction-containing-metadata"},"The Lifetime of a Transaction Containing Metadata"),Object(s.b)("p",null,"The first step to submitting a transaction is producing the metadata. The sender first produces a ",Object(s.b)("em",{parentName:"p"},"Libra Canonically Serialized (LCS)")," metadata_wrapper consisting of an LCS-serialized MetadataType object:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{}),"enum MetadataType {\n  Undefined,\n  GeneralMetadataType(GeneralMetadata),\n  TravelRuleMetadataType(TravelRuleMetadata),\n  UnstructuredBytesMetadataType(UnstructuredBytesMetadata),\n}\n\n// Used for versioning of general metadata\nenum GeneralMetadata {\n    GeneralMetadataVersion0(GeneralMetadatav0),\n}\n\nstruct GeneralMetadatav0 {\n    // Subaddress to which the funds are being sent\n    Option<Vec<u8>> to_subaddress,\n\n    // Subaddress from which the funds are being sent\n    Option<Vec<u8>> from_subaddress,\n\n    // Event sequence number of the `SentPaymentEvent` that this transaction is refunding\n    Option<u64> referenced_event,\n}\n\n// Used for versioning of travel rule metadata\nenum TravelRuleMetadata {\n    TravelRuleMetadataVersion0(TravelRuleMetadatav0),\n}\n\nstruct TravelRuleMetadatav0 {\n    // Off-chain reference_id.  Used when off-chain APIs are used.\n    // Specifies the off-chain reference ID that was agreed upon in off-chain APIs.\n    Option<String> off_chain_reference_id,\n}\n\nstruct UnstructuredBytesMetadata {\n    // Unstructured bytes metadata\n    Option<Vec<u8>> metadata,\n}\n")),Object(s.b)("p",null,'Using the initial example described in the motivation, the merchant whose wallet\'s subaddress for this payment is "merch_a", is hosted by a custodian with a public address of 0x1234 may post a URI for shoes that cost 20 microlibra.  The purchaser would then submit a transaction containing the following metadata:'),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{}),'0x01, 0x00, 01, "merch_a", 00, 00, 00\n/* general_metadata_type, general_metadata_v0,\n      to_subaddress_present, to_subaddress,\n      from_subaddress_not_present,\n      referenced_event_not_present */\n')),Object(s.b)("h2",{id:"submitting-a-transaction"},"Submitting a transaction"),Object(s.b)("p",null,"With the metadata in hand, the sender can now submit a transaction to the Libra block chain via a ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/libra/libra/blob/master/language/stdlib/transaction_scripts/doc/peer_to_peer_with_metadata.md"}),"deposit call")," in Move. Note that metadata_signature must only be present for travel-rule cases between VASPs."),Object(s.b)("h2",{id:"processing-the-transaction"},"Processing the transaction"),Object(s.b)("p",null,"Much like any other funds transfer request, validators only verify that the sender has the sufficient libra to support the transaction and that the transaction is properly formed and valid, they do not inspect or verify the correctness of the metadata."),Object(s.b)("p",null,"The recipient custodian should make an effort to refund in the case of malformed metadata or an invalid subaddress for the recipient."),Object(s.b)("h1",{id:"transaction-examples"},"Transaction Examples"),Object(s.b)("p",null,"The following examples demonstrate how subaddressing and metadata are used in the transaction flow.  ",Object(s.b)("em",{parentName:"p"},"Note that the terminology \u201cNC\u201d will mean non-custodial account and \u201cC\u201d will mean a custodial account.")),Object(s.b)("h2",{id:"nc-to-nc-transaction-flow"},"NC to NC transaction Flow"),Object(s.b)("p",null,"For NC to NC transactions, there is no usage of subaddressing/metadata."),Object(s.b)("h2",{id:"nc-to-c-transaction-flow"},"NC to C Transaction Flow"),Object(s.b)("p",null,"User A (address 0x1234) on a NC wallet wishes to send 100 microlibra to merchant B who is on a private custodial wallet (Where the custodial wallet has a public address of 0x7777 and the merchant has a sub-account of 'bob').  User A's client now composes a raw transaction with the following relevant fields:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{}),"metadata = GeneralMetadatav0 {\n  to_subaddress: 'bob',\n};\n\nprogram = encode_peer_to_peer_with_metadata_script(\n    \"LBR\" /*currency*/,\n    0x7777 /*recipient*/,\n    100 /*amount*/,\n    lcs(MetadataType::GeneralMetadataType(\n        GeneralMetadata::GeneralMetadataVersion0(metadata))),\n    None /*metadata_signature*/);\n\nRawTransaction {\n    sender_account: 0x1234,\n    program: program,\n}\n")),Object(s.b)("h2",{id:"c-to-nc-transaction-flow"},"C to NC transaction flow"),Object(s.b)("p",null,"User A who is on a custodial wallet (Where the C wallet has a public address of 0x7777 and user A has a sub-account of 'alice') wishes to send 100 microlibra to merchant B who is on a NC wallet (with an address of 0x1234).  User A's wallet then composes a transaction via:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{}),"metadata = GeneralMetadatav0 {\n  from_subaddress: 'alice',\n};\n\nprogram = encode_peer_to_peer_with_metadata_script(\n    \"LBR\" /*currency*/,\n    0x1234 /*recipient*/,\n    100 /*amount*/,\n    lcs(MetadataType::GeneralMetadataType(\n        GeneralMetadata::GeneralMetadataVersion0(metadata))),\n    None /*metadata_signature*/);\n\nRawTransaction {\n    sender_account: 0x7777,\n    program: program,\n}\n")),Object(s.b)("h2",{id:"refunds"},"Refunds"),Object(s.b)("p",null,"Merchant B now wishes to refund user A. But user A was sending from a custodial account so merchant B must send the funds back to the custodial account and include subaddress information so that the funds are directed back to user A.  Merchant B\u2019s client now constructs a transaction via the following where referenced_event is the committed event sequence number under the sending account of the original sent payment event:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{}),"metadata = GeneralMetadatav0 {\n  to_subaddress: 'alice',\n  referenced_event: 123,\n};\n\nprogram = encode_peer_to_peer_with_metadata_script(\n    \"LBR\" /*currency*/,\n    0x7777 /*recipient*/,\n    100 /*amount*/,\n    lcs(MetadataType::GeneralMetadataType(\n        GeneralMetadata::GeneralMetadataVersion0(metadata))),\n    None /*metadata_signature*/);\n\nRawTransaction {\n    sender_account: 0x1234,\n    program: program,\n}\n")),Object(s.b)("h2",{id:"c-to-c-transaction-flow"},"C to C transaction flow"),Object(s.b)("p",null,"For transactions under the travel rule threshold, transaction metadata inclusive of both to_subaddress and from_subaddress should be composed."),Object(s.b)("p",null,"For transactions over the travel rule limit, custodial to custodial transactions must follow the off-chain API specification, so the suggested way to exchange the metadata is during this off-chain exchange rather than using purely subaddressing.  More details can be seen in LIP-1.  Once the off-chain APIs have been utilized, there will be an off-chain reference ID which represents this transaction.  The on-chain transaction is now constructed."),Object(s.b)("p",null,"User A who is on a custodial wallet (Where the C wallet has a public address of 0x7777 and user A has a sub-account of 'alice') wishes to send 100 microlibra to merchant B who is on a C wallet (where the C wallet has a public address of 0x1234 and merchant B has a sub-account of 'bob').  User A's wallet then composes a transaction via (note that the to/from subaddresses are not included since they were passed via the off-chain API):"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{}),'metadata = TravelRuleMetadatav0 {\n  off_chain_reference_id: "123abc",\n};\n\nlcs_metadata = lcs(MetadataType::TravelRuleMetadataType(\n        TravelRuleMetadata::TravelRuleMetadataVersion0(metadata))),\n\n// The receiver side will have signed this as part of the off-chain APIs\n// and will have sent it to the sender side.\n// The following was done by the receiver VASP and given to the sender VASP\n// via the off-chain protocol:\n    // receiver_lcs_data = lcs(metadata, sender_address, amount, "@@$$LIBRA_ATTEST$$@@" /*ASCII-encoded string*/);\n    // receiver_metadata_signature = sign(receiver_lcs_data, receiver_key /* key used to sign */);\n\nprogram = encode_peer_to_peer_with_metadata_script(\n    "LBR" /*currency*/,\n    0x1234 /*recipient*/,\n    100 /*amount*/,\n    metadata,\n    receiver_metadata_signature);\n\nRawTransaction {\n    sender_account: 0x7777,\n    program: program,\n}\n')))}l.isMDXComponent=!0},196:function(e,t,a){"use strict";a.d(t,"a",(function(){return u})),a.d(t,"b",(function(){return p}));var n=a(0),r=a.n(n);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var d=r.a.createContext({}),l=function(e){var t=r.a.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):i({},t,{},e)),a},u=function(e){var t=l(e.components);return r.a.createElement(d.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,s=e.originalType,o=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),u=l(a),b=n,p=u["".concat(o,".").concat(b)]||u[b]||h[b]||s;return a?r.a.createElement(p,i({ref:t},d,{components:a})):r.a.createElement(p,i({ref:t},d))}));function p(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=a.length,o=new Array(s);o[0]=b;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,o[1]=i;for(var d=2;d<s;d++)o[d]=a[d];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,a)}b.displayName="MDXCreateElement"}}]);